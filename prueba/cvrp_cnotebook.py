# -*- coding: utf-8 -*-
"""CVRP_CNotebook.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G7LfxjqzY89PEErJu7NgFSNw2ezaMwZS
"""

"""**Load Drivers and Locations**"""

import random
import string
import json
import pandas as pd

# Commented out IPython magic to ensure Python compatibility.
# %%writefile locations.txt
# [
#   { "id": 1.0, "demand": 3.0, "lat": 40.518348, "lng": -3.897235 },
#   { "id": 2.0, "demand": 5.0, "lat": 40.519669, "lng": -3.900518 },
#   { "id": 3.0, "demand": 8.0, "lat": 40.520794, "lng": -3.896012 },
#   { "id": 4.0, "demand": 2.0, "lat": 40.519228, "lng": -3.891806 },
# 
#   { "id": 5.0, "demand": 1.0, "lat": 40.522425, "lng": -3.894338 },
#   { "id": 6.0, "demand": 4.0, "lat": 40.523681, "lng": -3.892622 },
#   { "id": 7.0, "demand": 6.0, "lat": 40.523535, "lng": -3.890347 },
#   { "id": 8.0, "demand": 1.0, "lat": 40.526291, "lng": -3.893652 }
# ]
#

# Commented out IPython magic to ensure Python compatibility.
# %%writefile drivers.txt
# [
#   {
#     "id": 1,
#     "license_plate": "123BC",
#     "driver": "JUAN",
#     "capacity": 15,
#     "lat": 40.520566,
#     "lng": -3.909616
#   },
#   {
#     "id": 2,
#     "license_plate": "12LOP6",
#     "driver": "MANUEL",
#     "capacity": 15,
#     "lat": 40.526405,
#     "lng": -3.893652
#   },
#   {
#     "id": 3,
#     "license_plate": "543OPC",
#     "driver": "DANIEL",
#     "capacity": 15,
#     "lat": 40.519163,
#     "lng": -3.887558
#   }
# ]

def load_data(file_dr, file_loc):
  
  def create_df(dic):
    c_names = [key for key in dic[0].keys()]
    df = pd.DataFrame(columns = c_names)
    i = 0

    for elem in dic:
      vals = []

      for c in c_names:
        vals.append(elem[c])
      
      df.loc[i] = vals
      i+= 1
    
    return df

  f = open('drivers.txt',)
  json_drivers = json.load(f)

  f = open('locations.txt',)
  json_locations = json.load(f)


  df_drivers = create_df(json_drivers)
  df_locations = create_df(json_locations)
  
  # filtrar locations < 30
  # df_locations = df_locations[df_locations.demand > 30]

  return df_drivers, df_locations

df_drivers, df_locations = load_data('drivers.txt', 'locations.txt')
df_locations

import requests 
import json 
import numpy as np

"""**Google Maps API**"""
import googlemaps
import requests
import json

api_key = "AIzaSyAMot24WThCTr8aJCBRlvLzrUrrmqhKLlM"

def reverse_geo(lat, lon):
  gmaps = googlemaps.Client(key=api_key)
  geocode = gmaps.reverse_geocode((lat,lon))

  loc = ""
  
  for x in geocode[0]['address_components']:
    loc+= x['long_name'] + " "

  return loc[:-1]

def get_route_points(lat1, lon1, lat2, lon2):
  endpoint = 'https://maps.googleapis.com/maps/api/directions/json?'
  
  origin = reverse_geo(lat1,lon1).replace(' ','+')
  destination = reverse_geo(lat2,lon1).replace(' ','+')
  
  nav_request = 'origin={}&destination={}&key={}'.format(origin,destination,api_key)
  request = endpoint + nav_request
  response = json.loads(requests.get(request).text)
  
  route = [[lat1,lon1]]

  if(len(response['routes']) > 0):

    for x in response['routes'][0]['legs'][0]['steps']:
      route.append( [ x['end_location']['lat'], x['end_location']['lng'] ])
  
  route.append([lat2, lon2])

  return route

def get_distance(lat1, lon1, lat2, lon2):
  endpoint = 'https://maps.googleapis.com/maps/api/directions/json?'
  
  origin = reverse_geo(lat1,lon1).replace(' ','+')
  destination = reverse_geo(lat2,lon1).replace(' ','+')
  
  nav_request = 'origin={}&destination={}&key={}'.format(origin,destination,api_key)
  request = endpoint + nav_request
  response = json.loads(requests.get(request).text)

  dist = 0
  
  if(len(response['routes']) == 0):
    return 0

  for x in response['routes'][0]['legs'][0]['steps']:
    dist+=x['distance']['value']

  return dist #metros

get_distance(-12.113267, -76.974553, -12.112499, -76.974175)

def create_distance_matrix(latList, lonList):

    n = len(latList)

    M = np.zeros(shape=(n,n))

    for i in range(n):
        for j in range(i + 1, n):
          
            dist = get_distance(latList[i],lonList[i],latList[j],lonList[j])
            
            M[i, j] = dist
            M[j, i] = dist

    return M

"""**Create Model**"""

def create_model(df_drivers, df_locations):

  ## multidepot

  n_drivers = df_drivers.shape[0]
  
  lng_combined = df_drivers.lng.to_list()  + df_locations.lng.to_list()
  lat_combined = df_drivers.lat.to_list() + df_locations.lat.to_list()

  data = {}
  data['latitudes'] = [ float(lat) for lat in lat_combined ]
  data['longitudes'] = [ float(lng) for lng in lng_combined ]
  data['distance_matrix'] = create_distance_matrix(lat_combined, lng_combined)
  data['demands'] = [0]*n_drivers + df_locations.demand.to_list()
  data['vehicle_capacities'] = df_drivers.capacity.to_list()
  data['num_vehicles'] = n_drivers
  data['depot'] = 0


  data['starts'] = []
  data['ends'] = []
  for i in range(n_drivers):
    data['starts'].append(i)
    data['ends'].append(i)

  return data

data = create_model(df_drivers, df_locations)

print(data)

"""**CVRP Solver**"""

from ortools.constraint_solver import pywrapcp, routing_enums_pb2

def get_solution(data):

  manager = pywrapcp.RoutingIndexManager(len(data['distance_matrix']),
                                           data['num_vehicles'], data['starts'], data['ends'])
  
  routing = pywrapcp.RoutingModel(manager)

  # Constante distancia
  def distance_callback(from_index, to_index):
        from_node = manager.IndexToNode(from_index)
        to_node = manager.IndexToNode(to_index)
        return data['distance_matrix'][from_node][to_node]

  transit_callback_index = routing.RegisterTransitCallback(distance_callback)

  routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)


  # Constante capacidad
  def demand_callback(from_index):
        from_node = manager.IndexToNode(from_index)
        return data['demands'][from_node]

  demand_callback_index = routing.RegisterUnaryTransitCallback(demand_callback)
  
  routing.AddDimensionWithVehicleCapacity(
        demand_callback_index,
        0,  # slack
        data['vehicle_capacities'],  # Maximas Capacidades
        True,  # Empezar a acumular desde 0
        'Capacity')

  # Heuristica
  search_parameters = pywrapcp.DefaultRoutingSearchParameters()
  search_parameters.first_solution_strategy = (
        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC)
  search_parameters.local_search_metaheuristic = (
        routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH)
  search_parameters.time_limit.FromSeconds(1)

  # Solucionar el problema
  solution = routing.SolveWithParameters(search_parameters)
  print(f'Objective: {solution.ObjectiveValue()}')
  return (solution, manager, routing)

solution, manager, routing = get_solution(data)

"""**Get Route of every Driver**"""

def get_full_route(data, manager, routing, solution, df_drivers):
    
  answer = []
  
  for vehicle_id in range(data['num_vehicles']):
    index = routing.Start(vehicle_id)
    plan_output = 'Ruta del vehiculo {}:\n'.format(vehicle_id)
    # id, distance, license_plate, driver, route(matrix)
    
    route = []
    lon = df_drivers.lng[vehicle_id]
    lat =  df_drivers.lat[vehicle_id]

    route_distance = 0
    route_load = 0

    plan_output = ""
    while not routing.IsEnd(index):
      node_index = manager.IndexToNode(index)
      route_load += data['demands'][node_index]

      lon = data['longitudes'][node_index]
      lat = data['latitudes'][node_index]
      route.append([ lat, lon ])

      plan_output += ' {0} Carga({1}) -> '.format(node_index, route_load)
      previous_index = index
      index = solution.Value(routing.NextVar(index))
      route_distance += routing.GetArcCostForVehicle(previous_index, index, vehicle_id)
        
    
    plan_output += ' {0} Carga({1})\n'.format(manager.IndexToNode(index), route_load)
    
    lon = data['longitudes'][manager.IndexToNode(index)]
    lat = data['latitudes'][manager.IndexToNode(index)]
    
    print(plan_output)

    route.append( [lat, lon] )   

    full_route = []

    for i in range(len(route) - 1):
      full_route+= get_route_points(route[i][0], route[i][1], route[i+1][0], route[i+1][1])
      

    elem = {
      'id': df_drivers.id[vehicle_id],
      'distance' : route_distance,
      'license_plate' : df_drivers.license_plate[vehicle_id],
      'route': full_route
    }

    answer.append(elem)
  

  return answer

print(solution)

if(solution):
  answer = get_full_route(data,manager,routing,solution,df_drivers)

for x in answer:
  print(x)

"""**Plot routes**"""

import matplotlib.pyplot as plt
import matplotlib.image as mpimg

def route_split(route):
  xs = []
  ys = []
  for z in route:
    xs.append(z[0])
    ys.append(z[1])
  
  return xs, ys

xs = []
ys = []

color = ['blue', 'red', 'yellow', 'orange', 'green', 'cyan']
cli = 0

for z in answer:
  prevx = -1
  prevy = -1

  for i in range(len(z['route'])):
    
    xs.append(z['route'][i][0])
    ys.append(z['route'][i][1])

    if(i > 0):
      x_values = [prevx, xs[-1]]
      y_values = [prevy, ys[-1]]
      
      plt.plot(x_values, y_values, color=color[cli])
    
    prevx, prevy = xs[-1], ys[-1]
  
  cli+=1
  
plt.scatter(xs, ys)